{"ast":null,"code":"var _jsxFileName = \"/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/src/components/AudioPlayer/AudioPlayer.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport AudioControls from './AudioControls.jsx';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst AudioPlayer = ({\n  tracks,\n  onChangeTrack,\n  onPauseTrack\n}) => {\n  _s();\n\n  // index of track being played\n  const [trackIndex, setTrackIndex] = useState(0); // current progress of track being played\n\n  const [trackProgress, setTrackProgress] = useState(0); // wether or not track is being played\n\n  const [isPlaying, setIsPlaying] = useState(false); // current title and source equal the current track index\n\n  const {\n    title,\n    audioSrc\n  } = tracks[trackIndex]; // stores Audio element plus audio source in a ref\n\n  const audioRef = useRef(new Audio(audioSrc));\n  const intervalRef = useRef();\n  const isReady = useRef(false);\n  const {\n    duration\n  } = audioRef.current;\n  const currentPercentage = duration ? `${trackProgress / duration * 100}%` : '0%';\n  const trackStyling = `-webkit-gradient(linear, 0% 0%, 100% 0%, color-stop(${currentPercentage}, #fff), color-stop(${currentPercentage}, #777))`; // PREV -  handles previous track click\n\n  const toPrevTrack = () => {\n    // if trackIndex minus 1 is less than zero, set track index to the last track\n    if (trackIndex - 1 < 0) {\n      setTrackIndex(tracks.length - 1);\n    } else {\n      setTrackIndex(trackIndex - 1);\n    }\n  }; // NEXT - handles next track click\n\n\n  const toNextTrack = () => {\n    // if trackIndex is less than tracks length go to next track, otherwise go to first track\n    if (trackIndex < tracks.length - 1) {\n      setTrackIndex(trackIndex + 1);\n    } else {\n      setTrackIndex(0);\n    }\n  }; // PLAY\n\n\n  useEffect(() => {\n    // when isPlaying changes:\n    // if isPlaying state is false, play the track in audio tag \n    if (isPlaying) {\n      // update track for analyser\n      audioRef.current.play();\n      console.log('setting track');\n      onChangeTrack(audioRef.current);\n      startTimer();\n    } else {\n      // otherwise clear the intervalRef and pause the track in audio tag\n      console.log('pause track');\n      clearInterval(intervalRef.current);\n      audioRef.current.pause();\n    }\n  }, [isPlaying]);\n  useEffect(() => {\n    // pause and clean up on unmount / clear any setInterval timers\n    return () => {\n      audioRef.current.pause();\n      clearInterval(intervalRef.current);\n    };\n  }, []); // NEXT track\n\n  useEffect(() => {\n    // runs when trackIndex is updated, allowing current track to be paused while\n    // updating the value of audioRef to new source, resetting the progress state and \n    // setting new track to play\n    audioRef.current.pause();\n    audioRef.current = new Audio(audioSrc);\n    setTrackProgress(audioRef.current.currentTime);\n\n    if (isReady.current) {\n      audioRef.current.play();\n      setIsPlaying(true);\n      startTimer();\n    } else {\n      isReady.current = true;\n    }\n  }, [trackIndex]);\n\n  const startTimer = () => {\n    // clear any timers already running\n    clearInterval(intervalRef.current); // check track every second, if ended go to next track, otherwise update track progress\n\n    intervalRef.current = setInterval(() => {\n      if (audioRef.current.ended) {\n        toNextTrack();\n      } else {\n        setTrackProgress(audioRef.current.currentTime);\n      }\n    }, [1000]);\n  };\n\n  const onScrub = value => {\n    // clear any timers already running\n    clearInterval(intervalRef.current);\n    audioRef.current.currentTime = value;\n    setTrackProgress(audioRef.current.currentTime);\n  };\n\n  const onScrubEnd = () => {\n    // if isPlayings value is false then set it to true\n    if (!isPlaying) {\n      setIsPlaying(true);\n    }\n\n    startTimer();\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"audio-player\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"track-info\",\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        className: \"title\",\n        children: title\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 129,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(AudioControls, {\n        isPlaying: isPlaying,\n        onPrevClick: toPrevTrack,\n        onNextClick: toNextTrack,\n        onPlayPauseClick: setIsPlaying // onPlay={toggleTrack}\n\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 130,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"range\",\n        value: trackProgress,\n        step: \"1\",\n        min: \"0\",\n        max: duration ? duration : `${duration}`,\n        className: \"progress\",\n        onChange: e => onScrub(e.target.value),\n        onMouseUp: onScrubEnd,\n        onKeyUp: onScrubEnd,\n        style: {\n          background: trackStyling\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 137,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 127,\n    columnNumber: 9\n  }, this);\n};\n\n_s(AudioPlayer, \"E9Pm1fLhcuO8D0WYi7gJIZx8ngQ=\");\n\n_c = AudioPlayer;\nexport default AudioPlayer;\n\nvar _c;\n\n$RefreshReg$(_c, \"AudioPlayer\");","map":{"version":3,"sources":["/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/src/components/AudioPlayer/AudioPlayer.jsx"],"names":["React","useState","useEffect","useRef","AudioControls","AudioPlayer","tracks","onChangeTrack","onPauseTrack","trackIndex","setTrackIndex","trackProgress","setTrackProgress","isPlaying","setIsPlaying","title","audioSrc","audioRef","Audio","intervalRef","isReady","duration","current","currentPercentage","trackStyling","toPrevTrack","length","toNextTrack","play","console","log","startTimer","clearInterval","pause","currentTime","setInterval","ended","onScrub","value","onScrubEnd","e","target","background"],"mappings":"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","sourcesContent":["import React, {useState, useEffect, useRef} from 'react';\nimport AudioControls from './AudioControls.jsx';\n\nconst AudioPlayer = ({ tracks, onChangeTrack, onPauseTrack }) => {\n\n    // index of track being played\n    const [trackIndex, setTrackIndex] = useState(0);\n    // current progress of track being played\n    const [trackProgress, setTrackProgress] = useState(0);\n    // wether or not track is being played\n    const [isPlaying, setIsPlaying] = useState(false);\n    // current title and source equal the current track index\n    const {title, audioSrc} = tracks[trackIndex];\n    \n    // stores Audio element plus audio source in a ref\n    const audioRef = useRef(new Audio(audioSrc));\n    \n    const intervalRef = useRef();\n    const isReady = useRef(false);\n\n    const { duration } = audioRef.current;\n    const currentPercentage = duration ? `${(trackProgress / duration) * 100}%` : '0%';\n    const trackStyling = `-webkit-gradient(linear, 0% 0%, 100% 0%, color-stop(${currentPercentage}, #fff), color-stop(${currentPercentage}, #777))`;\n\n    // PREV -  handles previous track click\n    const toPrevTrack = () => {\n        // if trackIndex minus 1 is less than zero, set track index to the last track\n        if (trackIndex - 1 < 0){\n            setTrackIndex(tracks.length - 1);\n        } else {\n            setTrackIndex(trackIndex - 1);\n        }\n    }\n    \n    // NEXT - handles next track click\n    const toNextTrack = () => {\n        // if trackIndex is less than tracks length go to next track, otherwise go to first track\n        if (trackIndex < tracks.length -1){\n            setTrackIndex(trackIndex + 1);\n        } else {\n            setTrackIndex(0);\n        }\n    }\n    \n    // PLAY\n    useEffect(() => {\n        // when isPlaying changes:\n        // if isPlaying state is false, play the track in audio tag \n        if(isPlaying) {\n            // update track for analyser\n            \n            audioRef.current.play();\n            console.log('setting track')\n            onChangeTrack(audioRef.current)\n            startTimer();\n        } else {\n            // otherwise clear the intervalRef and pause the track in audio tag\n            console.log('pause track')\n            clearInterval(intervalRef.current)\n            audioRef.current.pause();\n        }\n    },[isPlaying])\n\n    useEffect(() => {\n        // pause and clean up on unmount / clear any setInterval timers\n\n        return () => {\n            audioRef.current.pause();\n            clearInterval(intervalRef.current);\n        }\n\n    }, [])\n\n    // NEXT track\n    useEffect(() => {\n        \n        // runs when trackIndex is updated, allowing current track to be paused while\n        // updating the value of audioRef to new source, resetting the progress state and \n        // setting new track to play\n\n        audioRef.current.pause()\n        audioRef.current = new Audio(audioSrc);\n        setTrackProgress(audioRef.current.currentTime);\n\n        if (isReady.current) {\n      \n            audioRef.current.play();\n            setIsPlaying(true);\n            startTimer()\n        } else {\n            isReady.current = true;\n        }\n    }, [trackIndex])\n\n    const startTimer = () => {\n        // clear any timers already running\n        clearInterval(intervalRef.current);\n\n        // check track every second, if ended go to next track, otherwise update track progress\n        intervalRef.current = setInterval(() => {\n            if (audioRef.current.ended) {\n                toNextTrack();\n            } else {\n                setTrackProgress(audioRef.current.currentTime);\n            }\n        }, [1000])\n    }\n\n\n    const onScrub = (value) => {\n        // clear any timers already running\n        clearInterval(intervalRef.current);\n        audioRef.current.currentTime = value;\n        setTrackProgress(audioRef.current.currentTime);\n    }\n\n    const onScrubEnd = () => {\n        // if isPlayings value is false then set it to true\n        if (!isPlaying) {\n            setIsPlaying(true);\n        }\n        startTimer();\n    }   \n\n    return(\n        \n        <div className=\"audio-player\">\n            <div className=\"track-info\">\n                <h3 className=\"title\">{title}</h3>\n                <AudioControls\n                    isPlaying={isPlaying}\n                    onPrevClick={toPrevTrack}\n                    onNextClick={toNextTrack}\n                    onPlayPauseClick={setIsPlaying}\n                    // onPlay={toggleTrack}\n                />\n                <input \n                    type=\"range\"\n                    value={trackProgress}\n                    step=\"1\"\n                    min=\"0\"\n                    max={duration ? duration : `${duration}`}\n                    className=\"progress\"\n                    onChange={(e) => onScrub(e.target.value)}\n                    onMouseUp={onScrubEnd}\n                    onKeyUp={onScrubEnd}\n                    style={{ background: trackStyling}}\n                />\n            </div>\n        </div>\n\n    ) \n            \n\n}\n\nexport default AudioPlayer;"]},"metadata":{},"sourceType":"module"}