{"ast":null,"code":"var _jsxFileName = \"/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/src/components/AudioVisualiser.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet testWaveFormRef = useRef(Array.from({\n  length: 1024\n}, () => Math.floor(Math.random() * 255)));\nconst testWaveForm = testWaveFormRef.current;\n\nconst AudioVisualiser = ({\n  audioData\n}) => {\n  _s();\n\n  const canvasRef = useRef();\n  useEffect(() => {\n    let canvas = canvasRef.current;\n    let height = canvas.height;\n    let width = canvas.width;\n    let context = canvas.getContext('2d');\n    let x = 0;\n    let sliceWidth = width * 0.5 / audioData.length;\n    let requestId;\n\n    const render = () => {\n      context.lineWidth = 2;\n      context.strokeStyle = '#000000'; // when not clearingRect waveform displays\n\n      context.clearRect(0, 0, width, height);\n      context.beginPath();\n      context.moveTo(0, height / 2);\n\n      for (const item of audioData) {\n        const y = item / 255.0 * height;\n        context.lineTo(x, y);\n        x += sliceWidth;\n      }\n\n      context.lineTo(x, height / 2);\n      context.stroke();\n      requestId = requestAnimationFrame(render);\n    };\n\n    render();\n    return function cleanup() {\n      cancelAnimationFrame(requestId);\n    };\n  });\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    width: \"300\",\n    height: \"300\",\n    ref: canvasRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 50,\n    columnNumber: 9\n  }, this);\n};\n\n_s(AudioVisualiser, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n\n_c = AudioVisualiser;\nexport default AudioVisualiser;\n\nvar _c;\n\n$RefreshReg$(_c, \"AudioVisualiser\");","map":{"version":3,"sources":["/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/src/components/AudioVisualiser.js"],"names":["React","useRef","useEffect","testWaveFormRef","Array","from","length","Math","floor","random","testWaveForm","current","AudioVisualiser","audioData","canvasRef","canvas","height","width","context","getContext","x","sliceWidth","requestId","render","lineWidth","strokeStyle","clearRect","beginPath","moveTo","item","y","lineTo","stroke","requestAnimationFrame","cleanup","cancelAnimationFrame"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,MAAf,EAAuBC,SAAvB,QAAuC,OAAvC;;AAEA,IAAIC,eAAe,GAAGF,MAAM,CAACG,KAAK,CAACC,IAAN,CAAW;AAACC,EAAAA,MAAM,EAAE;AAAT,CAAX,EAA2B,MAAMC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,GAA3B,CAAjC,CAAD,CAA5B;AACI,MAAMC,YAAY,GAAGP,eAAe,CAACQ,OAArC;;AAEJ,MAAMC,eAAe,GAAG,CAAC;AAACC,EAAAA;AAAD,CAAD,KAAiB;AAAA;;AAErC,QAAMC,SAAS,GAAGb,MAAM,EAAxB;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIa,MAAM,GAAGD,SAAS,CAACH,OAAvB;AACA,QAAIK,MAAM,GAAGD,MAAM,CAACC,MAApB;AACA,QAAIC,KAAK,GAAGF,MAAM,CAACE,KAAnB;AACA,QAAIC,OAAO,GAAGH,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAAd;AACA,QAAIC,CAAC,GAAG,CAAR;AACA,QAAIC,UAAU,GAAIJ,KAAK,GAAG,GAAT,GAAgBJ,SAAS,CAACP,MAA3C;AAIA,QAAIgB,SAAJ;;AAEA,UAAMC,MAAM,GAAG,MAAM;AACjBL,MAAAA,OAAO,CAACM,SAAR,GAAoB,CAApB;AACAN,MAAAA,OAAO,CAACO,WAAR,GAAsB,SAAtB,CAFiB,CAGjB;;AACAP,MAAAA,OAAO,CAACQ,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBT,KAAxB,EAA+BD,MAA/B;AACAE,MAAAA,OAAO,CAACS,SAAR;AACAT,MAAAA,OAAO,CAACU,MAAR,CAAe,CAAf,EAAkBZ,MAAM,GAAG,CAA3B;;AAEA,WAAI,MAAMa,IAAV,IAAkBhB,SAAlB,EAA6B;AACzB,cAAMiB,CAAC,GAAID,IAAI,GAAG,KAAR,GAAiBb,MAA3B;AACAE,QAAAA,OAAO,CAACa,MAAR,CAAeX,CAAf,EAAkBU,CAAlB;AACAV,QAAAA,CAAC,IAAIC,UAAL;AACH;;AAEDH,MAAAA,OAAO,CAACa,MAAR,CAAeX,CAAf,EAAkBJ,MAAM,GAAG,CAA3B;AACAE,MAAAA,OAAO,CAACc,MAAR;AACAV,MAAAA,SAAS,GAAGW,qBAAqB,CAACV,MAAD,CAAjC;AACH,KAjBD;;AAmBAA,IAAAA,MAAM;AAEN,WAAO,SAASW,OAAT,GAAmB;AACtBC,MAAAA,oBAAoB,CAACb,SAAD,CAApB;AACH,KAFD;AAIH,GArCQ,CAAT;AAuCA,sBACI;AACA,IAAA,KAAK,EAAC,KADN;AAEA,IAAA,MAAM,EAAC,KAFP;AAGA,IAAA,GAAG,EAAER;AAHL;AAAA;AAAA;AAAA;AAAA,UADJ;AAQH,CAnDD;;GAAMF,e;;KAAAA,e;AAqDN,eAAeA,eAAf","sourcesContent":["import React, {useRef, useEffect} from 'react';\n\nlet testWaveFormRef = useRef(Array.from({length: 1024}, () => Math.floor(Math.random() * 255)));\n    const testWaveForm = testWaveFormRef.current;\n\nconst AudioVisualiser = ({audioData}) => {\n\n    const canvasRef = useRef();\n    \n    useEffect(() => {\n        let canvas = canvasRef.current;\n        let height = canvas.height;\n        let width = canvas.width;\n        let context = canvas.getContext('2d');\n        let x = 0;\n        let sliceWidth = (width * 0.5) / audioData.length;\n\n        \n        \n        let requestId;\n\n        const render = () => {\n            context.lineWidth = 2;\n            context.strokeStyle = '#000000';\n            // when not clearingRect waveform displays\n            context.clearRect(0, 0, width, height);\n            context.beginPath();\n            context.moveTo(0, height / 2);\n\n            for(const item of audioData) {\n                const y = (item / 255.0) * height;\n                context.lineTo(x, y);\n                x += sliceWidth;\n            }\n\n            context.lineTo(x, height / 2);\n            context.stroke();\n            requestId = requestAnimationFrame(render);\n        }\n        \n        render()\n\n        return function cleanup() {\n            cancelAnimationFrame(requestId)\n        }\n        \n    }, )\n\n    return(\n        <canvas \n        width=\"300\" \n        height=\"300\" \n        ref={canvasRef}\n        />\n    )\n\n}\n\nexport default AudioVisualiser;"]},"metadata":{},"sourceType":"module"}