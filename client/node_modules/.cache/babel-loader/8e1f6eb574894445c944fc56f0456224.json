{"ast":null,"code":"var _jsxFileName = \"/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/src/components/Visualisers/WaveformVisualiser.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect } from 'react'; //let testWaveFormRef = useRef(Array.from({length: 1024}, () => Math.floor(Math.random() * 255)));\n//  const testWaveForm = testWaveFormRef.current;\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst WaveformVisualiser = ({\n  audioData\n}) => {\n  _s();\n\n  const canvasRef = useRef(); //clear the canvas every 30 seconds\n\n  useEffect(() => {\n    const clearCanvas = () => {\n      context.clearRect(0, 0, width, height);\n    };\n\n    setInterval(clearCanvas, 30000);\n  }, []);\n  useEffect(() => {\n    let x = 0;\n    let sliceWidth = width * 0.5 / audioData.length;\n    let randomColour = \"#\" + ((1 << 24) * Math.random() | 0).toString(16);\n    let canvas = canvasRef.current;\n    let height = canvas.height;\n    let width = canvas.width;\n    let context = canvas.getContext('2d');\n\n    const render = () => {\n      context.lineWidth = 2;\n      context.strokeStyle = randomColour; // when not clearingRect waveform displays\n\n      context.beginPath();\n      context.moveTo(0, height / 2);\n\n      for (const item of audioData) {\n        const y = item / 255.0 * height;\n        context.lineTo(x, y);\n        x += sliceWidth;\n      }\n\n      context.lineTo(x, height / 2);\n      context.stroke();\n    };\n\n    render();\n  }, [audioData]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    className: \"canvas\",\n    width: \"5100\",\n    height: \"900\",\n    ref: canvasRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 56,\n    columnNumber: 9\n  }, this);\n};\n\n_s(WaveformVisualiser, \"1O11hef6JMAr7xpSnL0aZ5Ib60Q=\");\n\n_c = WaveformVisualiser;\nexport default WaveformVisualiser;\n\nvar _c;\n\n$RefreshReg$(_c, \"WaveformVisualiser\");","map":{"version":3,"sources":["/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/src/components/Visualisers/WaveformVisualiser.js"],"names":["React","useRef","useEffect","WaveformVisualiser","audioData","canvasRef","clearCanvas","context","clearRect","width","height","setInterval","x","sliceWidth","length","randomColour","Math","random","toString","canvas","current","getContext","render","lineWidth","strokeStyle","beginPath","moveTo","item","y","lineTo","stroke"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,MAAf,EAAuBC,SAAvB,QAAuC,OAAvC,C,CAEA;AACA;;;;AAEA,MAAMC,kBAAkB,GAAG,CAAC;AAACC,EAAAA;AAAD,CAAD,KAAiB;AAAA;;AAExC,QAAMC,SAAS,GAAGJ,MAAM,EAAxB,CAFwC,CAIxC;;AACAC,EAAAA,SAAS,CAAC,MAAM;AAEZ,UAAMI,WAAW,GAAG,MAAM;AACtBC,MAAAA,OAAO,CAACC,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBC,KAAxB,EAA+BC,MAA/B;AACH,KAFD;;AAGAC,IAAAA,WAAW,CAACL,WAAD,EAAc,KAAd,CAAX;AAEH,GAPQ,EAOP,EAPO,CAAT;AASAJ,EAAAA,SAAS,CAAC,MAAM;AAEZ,QAAIU,CAAC,GAAG,CAAR;AACA,QAAIC,UAAU,GAAIJ,KAAK,GAAG,GAAT,GAAgBL,SAAS,CAACU,MAA3C;AACA,QAAIC,YAAY,GAAG,MAAM,CAAC,CAAC,KAAG,EAAJ,IAAQC,IAAI,CAACC,MAAL,EAAR,GAAwB,CAAzB,EAA4BC,QAA5B,CAAqC,EAArC,CAAzB;AACA,QAAIC,MAAM,GAAGd,SAAS,CAACe,OAAvB;AACJ,QAAIV,MAAM,GAAGS,MAAM,CAACT,MAApB;AACA,QAAID,KAAK,GAAGU,MAAM,CAACV,KAAnB;AACA,QAAIF,OAAO,GAAGY,MAAM,CAACE,UAAP,CAAkB,IAAlB,CAAd;;AAII,UAAMC,MAAM,GAAG,MAAM;AACjBf,MAAAA,OAAO,CAACgB,SAAR,GAAoB,CAApB;AACAhB,MAAAA,OAAO,CAACiB,WAAR,GAAsBT,YAAtB,CAFiB,CAGjB;;AAEAR,MAAAA,OAAO,CAACkB,SAAR;AACAlB,MAAAA,OAAO,CAACmB,MAAR,CAAe,CAAf,EAAkBhB,MAAM,GAAG,CAA3B;;AAEA,WAAI,MAAMiB,IAAV,IAAkBvB,SAAlB,EAA6B;AACzB,cAAMwB,CAAC,GAAID,IAAI,GAAG,KAAR,GAAiBjB,MAA3B;AACAH,QAAAA,OAAO,CAACsB,MAAR,CAAejB,CAAf,EAAkBgB,CAAlB;AACAhB,QAAAA,CAAC,IAAIC,UAAL;AACH;;AAEDN,MAAAA,OAAO,CAACsB,MAAR,CAAejB,CAAf,EAAkBF,MAAM,GAAG,CAA3B;AACAH,MAAAA,OAAO,CAACuB,MAAR;AAEH,KAjBD;;AAmBAR,IAAAA,MAAM;AAET,GAjCQ,EAiCN,CAAClB,SAAD,CAjCM,CAAT;AAmCA,sBACI;AACI,IAAA,SAAS,EAAC,QADd;AAEI,IAAA,KAAK,EAAC,MAFV;AAGI,IAAA,MAAM,EAAC,KAHX;AAII,IAAA,GAAG,EAAEC;AAJT;AAAA;AAAA;AAAA;AAAA,UADJ;AASH,CA1DD;;GAAMF,kB;;KAAAA,kB;AA4DN,eAAeA,kBAAf","sourcesContent":["import React, {useRef, useEffect} from 'react';\n\n//let testWaveFormRef = useRef(Array.from({length: 1024}, () => Math.floor(Math.random() * 255)));\n//  const testWaveForm = testWaveFormRef.current;\n\nconst WaveformVisualiser = ({audioData}) => {\n\n    const canvasRef = useRef();\n    \n    //clear the canvas every 30 seconds\n    useEffect(() => {\n        \n        const clearCanvas = () => {\n            context.clearRect(0, 0, width, height);\n        }\n        setInterval(clearCanvas, 30000)\n\n    },[])\n\n    useEffect(() => {\n        \n        let x = 0;\n        let sliceWidth = (width * 0.5) / audioData.length;\n        let randomColour = \"#\" + ((1<<24)*Math.random() | 0).toString(16)\n        let canvas = canvasRef.current;\n    let height = canvas.height;\n    let width = canvas.width;\n    let context = canvas.getContext('2d');\n        \n        \n\n        const render = () => {\n            context.lineWidth = 2;\n            context.strokeStyle = randomColour;\n            // when not clearingRect waveform displays\n            \n            context.beginPath();\n            context.moveTo(0, height / 2);\n\n            for(const item of audioData) {\n                const y = (item / 255.0) * height;\n                context.lineTo(x, y);\n                x += sliceWidth;\n            }\n\n            context.lineTo(x, height / 2);\n            context.stroke();\n            \n        }\n        \n        render()\n        \n    }, [audioData])\n\n    return(\n        <canvas \n            className=\"canvas\"\n            width=\"5100\" \n            height=\"900\" \n            ref={canvasRef}\n        />\n    )\n\n}\n\nexport default WaveformVisualiser;"]},"metadata":{},"sourceType":"module"}