{"ast":null,"code":"var _jsxFileName = \"/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/client/src/components/Visualisers/WaveformVisualiser.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect } from 'react'; //let testWaveFormRef = useRef(Array.from({length: 1024}, () => Math.floor(Math.random() * 255)));\n//  const testWaveForm = testWaveFormRef.current;\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst WaveformVisualiser = ({\n  audioData,\n  setAnalyserDisconnected,\n  analyserDisconnected,\n  background\n}) => {\n  _s();\n\n  const canvasRef = useRef();\n  let canvas = canvasRef.current; //clear the canvas every 30 seconds\n  // useEffect(() => {\n  //     const clearCanvas = () => {\n  //         context.clearRect(0, 0, width, height);\n  //     }\n  //     setInterval(clearCanvas, 30000)\n  // },[])\n\n  useEffect(() => {\n    let x = 0;\n    let sliceWidth = width / audioData.length;\n    let randomColour = \"#\" + ((1 << 24) * Math.random() | 0).toString(16);\n\n    if (background === \"Black\") {\n      context.fillRect(0, 0, width, height);\n    } else {\n      context.fillStyle = '#000000';\n    } // if the analyser has been disconnected clear the canvas and reset analyserDisconnected to false\n\n\n    if (analyserDisconnected) {\n      context.clearRect(0, 0, width, height);\n      setAnalyserDisconnected(false);\n    }\n\n    const renderWaveform = () => {\n      if (background === \"Black\") {\n        context.fillRect(0, 0, width, height);\n      } else {\n        context.fillStyle = '#000000';\n      }\n\n      context.lineWidth = 2;\n      context.strokeStyle = randomColour;\n      context.beginPath();\n      context.moveTo(0, height / 2);\n\n      for (const item of audioData) {\n        const y = item / 255.0 * height;\n        context.lineTo(x, y);\n        x += sliceWidth;\n      } // console.log(\"Audio-data:\", audioData)\n\n\n      context.lineTo(x, height / 2);\n      context.stroke();\n    };\n\n    renderWaveform();\n  }, [audioData, background]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    className: \"canvas\",\n    width: \"550\",\n    height: \"550\",\n    ref: canvasRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 76,\n    columnNumber: 9\n  }, this);\n};\n\n_s(WaveformVisualiser, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n\n_c = WaveformVisualiser;\nexport default WaveformVisualiser;\n\nvar _c;\n\n$RefreshReg$(_c, \"WaveformVisualiser\");","map":{"version":3,"sources":["/Users/john/codeclan_work/final_project/full_stack_audio_processing_with_functions/audio_processing/client/src/components/Visualisers/WaveformVisualiser.js"],"names":["React","useRef","useEffect","WaveformVisualiser","audioData","setAnalyserDisconnected","analyserDisconnected","background","canvasRef","canvas","current","x","sliceWidth","width","length","randomColour","Math","random","toString","context","fillRect","height","fillStyle","clearRect","renderWaveform","lineWidth","strokeStyle","beginPath","moveTo","item","y","lineTo","stroke"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,MAAf,EAAuBC,SAAvB,QAAuC,OAAvC,C,CAEA;AACA;;;;AAEA,MAAMC,kBAAkB,GAAG,CAAC;AACxBC,EAAAA,SADwB;AAExBC,EAAAA,uBAFwB;AAGxBC,EAAAA,oBAHwB;AAIxBC,EAAAA;AAJwB,CAAD,KAKrB;AAAA;;AAEF,QAAMC,SAAS,GAAGP,MAAM,EAAxB;AACA,MAAIQ,MAAM,GAAGD,SAAS,CAACE,OAAvB,CAHE,CAKF;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEAR,EAAAA,SAAS,CAAC,MAAM;AAGZ,QAAIS,CAAC,GAAG,CAAR;AACA,QAAIC,UAAU,GAAGC,KAAK,GAAGT,SAAS,CAACU,MAAnC;AACA,QAAIC,YAAY,GAAG,MAAM,CAAC,CAAC,KAAG,EAAJ,IAAQC,IAAI,CAACC,MAAL,EAAR,GAAwB,CAAzB,EAA4BC,QAA5B,CAAqC,EAArC,CAAzB;;AACA,QAAGX,UAAU,KAAK,OAAlB,EAA0B;AACtBY,MAAAA,OAAO,CAACC,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAsBP,KAAtB,EAA6BQ,MAA7B;AACH,KAFD,MAEO;AACHF,MAAAA,OAAO,CAACG,SAAR,GAAoB,SAApB;AACH,KAVW,CAYZ;;;AACA,QAAGhB,oBAAH,EAAwB;AACpBa,MAAAA,OAAO,CAACI,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBV,KAAxB,EAA+BQ,MAA/B;AACAhB,MAAAA,uBAAuB,CAAC,KAAD,CAAvB;AACH;;AAGD,UAAMmB,cAAc,GAAG,MAAM;AAEzB,UAAGjB,UAAU,KAAK,OAAlB,EAA0B;AACtBY,QAAAA,OAAO,CAACC,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAsBP,KAAtB,EAA6BQ,MAA7B;AACH,OAFD,MAEO;AACHF,QAAAA,OAAO,CAACG,SAAR,GAAoB,SAApB;AACH;;AAEDH,MAAAA,OAAO,CAACM,SAAR,GAAoB,CAApB;AACAN,MAAAA,OAAO,CAACO,WAAR,GAAsBX,YAAtB;AAEAI,MAAAA,OAAO,CAACQ,SAAR;AACAR,MAAAA,OAAO,CAACS,MAAR,CAAe,CAAf,EAAkBP,MAAM,GAAG,CAA3B;;AAEA,WAAI,MAAMQ,IAAV,IAAkBzB,SAAlB,EAA6B;AACzB,cAAM0B,CAAC,GAAID,IAAI,GAAG,KAAR,GAAiBR,MAA3B;AACAF,QAAAA,OAAO,CAACY,MAAR,CAAepB,CAAf,EAAkBmB,CAAlB;AACAnB,QAAAA,CAAC,IAAIC,UAAL;AACH,OAlBwB,CAmBzB;;;AACAO,MAAAA,OAAO,CAACY,MAAR,CAAepB,CAAf,EAAkBU,MAAM,GAAG,CAA3B;AACAF,MAAAA,OAAO,CAACa,MAAR;AAEH,KAvBD;;AAyBAR,IAAAA,cAAc;AAGjB,GA/CQ,EA+CN,CAACpB,SAAD,EAAYG,UAAZ,CA/CM,CAAT;AAiDA,sBACI;AACI,IAAA,SAAS,EAAC,QADd;AAEI,IAAA,KAAK,EAAC,KAFV;AAGI,IAAA,MAAM,EAAC,KAHX;AAII,IAAA,GAAG,EAAEC;AAJT;AAAA;AAAA;AAAA;AAAA,UADJ;AASH,CA9ED;;GAAML,kB;;KAAAA,kB;AAgFN,eAAeA,kBAAf","sourcesContent":["import React, {useRef, useEffect} from 'react';\n\n//let testWaveFormRef = useRef(Array.from({length: 1024}, () => Math.floor(Math.random() * 255)));\n//  const testWaveForm = testWaveFormRef.current;\n\nconst WaveformVisualiser = ({\n    audioData, \n    setAnalyserDisconnected, \n    analyserDisconnected,\n    background\n}) => {\n\n    const canvasRef = useRef();\n    let canvas = canvasRef.current;\n\n    //clear the canvas every 30 seconds\n    // useEffect(() => {\n        \n    //     const clearCanvas = () => {\n    //         context.clearRect(0, 0, width, height);\n    //     }\n    //     setInterval(clearCanvas, 30000)\n\n    // },[])\n\n    useEffect(() => {\n        \n        \n        let x = 0;\n        let sliceWidth = width / audioData.length;\n        let randomColour = \"#\" + ((1<<24)*Math.random() | 0).toString(16)\n        if(background === \"Black\"){\n            context.fillRect(0, 0,width, height)\n        } else {\n            context.fillStyle = '#000000'\n        }\n        \n        // if the analyser has been disconnected clear the canvas and reset analyserDisconnected to false\n        if(analyserDisconnected){\n            context.clearRect(0, 0, width, height);\n            setAnalyserDisconnected(false)\n        }\n        \n\n        const renderWaveform = () => {\n            \n            if(background === \"Black\"){\n                context.fillRect(0, 0,width, height)\n            } else {\n                context.fillStyle = '#000000'\n            }\n            \n            context.lineWidth = 2;\n            context.strokeStyle = randomColour;\n            \n            context.beginPath();\n            context.moveTo(0, height / 2);\n\n            for(const item of audioData) {\n                const y = (item / 255.0) * height;\n                context.lineTo(x, y);\n                x += sliceWidth;\n            }\n            // console.log(\"Audio-data:\", audioData)\n            context.lineTo(x, height / 2);\n            context.stroke();\n            \n        }\n        \n        renderWaveform()\n        \n\n    }, [audioData, background])\n\n    return(\n        <canvas \n            className=\"canvas\"\n            width=\"550\" \n            height=\"550\" \n            ref={canvasRef}\n        />\n    )\n\n}\n\nexport default WaveformVisualiser;"]},"metadata":{},"sourceType":"module"}